#pragma once
#include <QFile>
#include <QString>

#include <utility>
#include <vector>

class IRecordConsumer
{
public:
    virtual void Consume(double timestamp, void *data, size_t len) const = 0;

protected:
    ~IRecordConsumer() = default;
};

/*
 * Handles the reading and processing of trace.dat file generated by trace-cmd
 * 
 * See TRACE-CMD.DAT(5) for documentation on the file format
 * 
 * This is a very incomplete implementation of ftrace ring buffer parer. Pretty much
 * all the edge cases are unhandled. But libeventparse or something like that that
 * comes with the kernel is LGPL licensed and I don't want to mess with that.
 */
class CTraceDat
{
public:
    enum ERecordType { Latency, Flyrecord };

    CTraceDat(const QString &fileName);

    bool IsLoaded() const { return bIsLoaded; }

    void ProcessRecords(const IRecordConsumer &consumer);

protected:
    QString ReadString();
    bool ReadInteger(uint16_t &out);
    bool ReadInteger(uint32_t &out);
    bool ReadInteger(uint64_t &out);
    bool CheckHeaderMagic();
    bool ParseInitialInfo();
    bool ParseEventFormats();
    bool ParseKAllSyms();
    bool ParseTracePrintkFormats();
    bool ParseProcessInformation();
    bool ParseRestOfHeader();

private:
    QFile File;

    int Version;
    bool bIsBigEndian;
    int LongSize;
    ERecordType RecType;

    std::vector<std::pair<uint64_t, uint64_t>> CPUData;

    bool bIsLoaded = false;
};
